% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/zzz.R
\name{FlexRL}
\alias{FlexRL}
\title{FlexRL}
\arguments{
\item{data}{is a list gathering information on the data to be linked such as the data
sources 'A' and 'B', the unique values in each PIV 'Nvalues', the list of PIVs to use for Record Linkage
and details on how each should be handled by the algorithm 'PIVs_config', potential bounds on the
mistakes probabilities for each PIV 'controlOnMistakes', whether there should be one parameter for
the mistakes in A and B or whether each source should have its own (sameMistakes=TRUE is recommended in case
of small data sources) 'sameMistakes', whether the parameters for mistakes should be fixed in case of instability
'phiMistakesAFixed' and 'phiMistakesBFixed', as well as the values they should be fixed to 'phiForMistakesA' and 'phiForMistakesB'}

\item{StEMIter}{The total number of iterations of the Stochastic EM algorithm (including the period to discard as burn-in)}

\item{StEMBurnin}{The number of iterations to discard as burn-in}

\item{GibbsIter}{The total number of iterations of the Gibbs sampler
(run in each iteration of the StEM) (including the period to discard as burn-in)}

\item{GibbsBurnin}{The number of iterations to discard as burn-in}
}
\value{
The StEM function returns w list with: Delta, the (sparse) matrix with the pairs of records linked and their
posterior probabilities to be linked (select the pairs where the proba>0.5 to get a valid set of linked records), as well as gamma,
eta, alpha, phi, the model parameters chains
}
\description{
A Flexible Model For Record Linkage
}
\details{
An example for a real data sources already encoded, with 5 PIVs: birth year, sex, marital status, education level, region.
PIVs may be considered stable if there is not enough information to model their dynamics.
We may not give a bound on the 3 last PIVs: marital status, education level, region, since there may be a lot of disagreements among the links for those variables.
For a small example we prefer having one parameter for the probabilities of mistakes over the 2 data sources.
We do not need to fix the mistakes parameters to avoid estimability problems here (since there is no 'unstable' variable defined).
More details are available on the experiments repository of our paper and in the vignettes.
}
\examples{
library(FlexRL)

df2016 = read.csv("vignettes/exA.csv", row.names = 1)
df2020 = read.csv("vignettes/exB.csv", row.names = 1)

PIVs_config = list( ANASCI     = list(stable = TRUE),
                    SESSO      = list(stable = TRUE),
                    STACIV     = list(stable = TRUE),
                    STUDIO     = list(stable = TRUE),
                    IREG       = list(stable = TRUE)
                  )
PIVs = names(PIVs_config)
PIVs_stable = sapply(PIVs_config, function(x) x$stable)

for(i in 1:length(PIVs))
{
  intersect_support_piv = intersect( unique(df2016[,PIVs[i]]), unique(df2020[,PIVs[i]]) )
  df2016 = df2016[df2016[,PIVs[i]] \%in\% c(NA,intersect_support_piv),]
  df2020 = df2020[df2020[,PIVs[i]] \%in\% c(NA,intersect_support_piv),]
}

rownames(df2016) = 1:nrow(df2016)
rownames(df2020) = 1:nrow(df2020)

links = intersect(df2016$ID, df2020$ID)
Nlinks = length(links)

TrueDelta = data.frame( matrix(0, nrow=0, ncol=2) )
for (i in 1:Nlinks)
{
  id = links[i]
  id16 = which(df2016$ID == id)
  id20 = which(df2020$ID == id)
  TrueDelta = rbind(TrueDelta, cbind(rownames(df2016[id16,]),rownames(df2020[id20,])))
}
true_pairs = do.call(paste, c(TrueDelta, list(sep="_")))

df2016$source = "df2016"
df2020$source = "df2020"

if(nrow(df2020)>nrow(df2016))
{
  encodedA = df2016
  encodedB = df2020
  cat("df2020 is the largest file, denoted encodedB")
}else
{
  encodedB = df2016
  encodedA = df2020
  cat("df2016 is the largest file, denoted encodedB")
}

levels_PIVs = lapply(PIVs, function(x) levels(factor(as.character(c(encodedA[,x], encodedB[,x])))))

for(i in 1:length(PIVs))
{
  encodedA[,PIVs[i]] = as.numeric(factor(as.character(encodedA[,PIVs[i]]), levels=levels_PIVs[[i]]))
  encodedB[,PIVs[i]] = as.numeric(factor(as.character(encodedB[,PIVs[i]]), levels=levels_PIVs[[i]]))
}
nvalues = sapply(levels_PIVs, length)
names(nvalues) = PIVs

encodedA[,PIVs][ is.na(encodedA[,PIVs]) ] = 0
encodedB[,PIVs][ is.na(encodedB[,PIVs]) ] = 0

data = list( A                    = encodedA,
             B                    = encodedB,
             Nvalues              = nvalues,
             PIVs_config          = PIVs_config,
             controlOnMistakes    = c(TRUE, TRUE, FALSE, FALSE, FALSE),
             sameMistakes         = TRUE,
             phiMistakesAFixed    = FALSE,
             phiMistakesBFixed    = FALSE,
             phiForMistakesA      = c(NA, NA, NA, NA, NA),
             phiForMistakesB      = c(NA, NA, NA, NA, NA)
           )

fit = stEM(  data                 = data,
             StEMIter             = 100,
             StEMBurnin           = 70,
             GibbsIter            = 200,
             GibbsBurnin          = 100,
             musicOn              = TRUE,
             newDirectory         = NULL,
             saveInfoIter         = FALSE
          )
}
\author{
Kayan√© Robach
}
